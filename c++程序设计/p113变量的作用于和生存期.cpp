// 例5-7 变量的作用域和生存期
#include <stdio.h>

void a (void);    // 函数原型
void b (void);    // 函数原型
void c (int i);   // 函数原型,i具有函数原型作用域,仅在该函数原型中可见

int x = 1;        // 全局变量(外部变量采用静态存储方式),具有文件作用域,从当前位置到文件结束都可见

int main (void)
{
	int x = 5;    // 局部变量,具有块作用域,从当前位置知道main结束可见

	printf ("main里面的局部变量x是%d.\n", x);

	{             // 开始新的块作用域
		int x = 7;// 局部变量,具有块作用域,从当前位置知道当前复合语句结束可见 // "最近嵌套原则"
		printf ("内层局部变量x的值是%d.\n", x); // 访问的是内层生命的x,外层声明的x不可见
	}
	
	printf ("main里面的局部变量x还是%d.\n", x);

	a ();         // 函数a使用了局部自动变量x
	b ();		  // 函数b使用了局部静态变量x
	c (10);		  // 函数c使用了全局变量x
    a ();         // 函数a中的局部自动变量x被重新建立
	b ();         // 局部静态变量保留了上次调用后的值
	c (10);       // 全局变量x保留了原来的值

	printf ("main里面的局部变量x还是%d.\n", x);

	return 0;
}

void a (void)
{
	int x = 25;    // 每次调用都重新建立并初始化

	printf ("a中的局部变量x在刚执行时的值为%d.\n", x);
	++x;
	printf ("a中的局部变量x在执行结束时的值为%d.\n", x); 
				   // 结束时,撤销局部自动变量x
}

void b (void)
{
	static int x = 50; // 只在 程 序 开始执行时初始化一次
	
	printf ("b中的静态局部变量值开始为%d.\n", x);
	++x;
	printf ("b中的局部变量x在执行结束时的值为%d.\n", x); 
					   // 结束时,局部静态变量x不被撤销
}

void c (int i)
{
	printf ("c中使用的全局变量x为%d.\n", x); // 使用全局变量x
	x *= i;
	printf ("c中使用的全局变量x为%d.\n", x);
}