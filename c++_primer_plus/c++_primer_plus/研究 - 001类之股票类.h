// p346开始研究 p373结束

// 类本身的学习			构造函数 析构函数 const成员函数 this指针 作用域为类的常量 ...

// 将数据和方法合成一个单元是类最吸引人的特性, 有了这种设计, 在创建对象的时候, 将会自动定制使用对象的规则;

#ifndef p343初始类_H_
#define p343初始类_H_

#include <string>

	// 类声明 - 一个保存用户对某公司持有股票的类;

class TempClass
{
private:
	double db;
};

class Stock
{
		// 只能用公有成员函数和友元函数访问private成员(默认访问方式);
		// 将数据放在类的私有部分称为数据隐藏, 它防止了程序直接访问数据成员, 这亦是一种封装, 将实现的细节封装在私有部分中;
private:
			// 这里只是声明了这些数据, 并没有赋值, 所以没有定义, 也没有分配空间, 所以可以放在头文件中, 文件的外部全局变量多次声明木有问题, 多次定义就不行了;
	std::string company;
	long		shares;		// 股份
	double		share_val;	// 股价
	double		total_val;	// 总持有价值
	
		// 定义位于类声明中的函数都将会自动成为内联函数, 不然放在头文件中也不允许;
	void set_tot(void){total_val = shares * share_val;}  // 内联函数是通过将函数限制成内部链接实现的可以放在头文件

		// 公有函数提供了对象和程序之间的接口;
public:
	
/*****************  关于构造函数 ******************/
	// 构造函数产生的原因:	. 要初始化对象, 而对象数据都是隐藏的, 所以必须用成员函数;
	//						. 成员函数初始化最好能保证在创建的时候进行初始化;
	//						. C++专门为初始化类对象提供了函数名和使用语法, 程序员只需要提供方法定义, 这个就是构造函数;
	// 构造函数的声明类型: 构造函数没有返回类型, 但是没有被声明为void, 事实上, 构造函数没有声明类型;

	//void acquire(const std::string &, long, double);
	Stock(const std::string &, long = 0.0, double = 0.0);  // 构造函数替换了acquire实现初始化功能
	Stock(void);	// 默认构造函数, 如果没有定义构造函数, C++自动添加默认构造函数, 但是如果自己定义了构造函数, 则C++不再提供默认构造函数
	// 初始化对象数组的方案是: 首先使用默认构造函数创建数组元素, 然后花括号中的构造函数将创建临时对象, 然后临时对象的内容复制到相应的元素中, 因此, 要创建对象数组, 这个类必须有默认构造函数
/*************************************************/

/*****************  关于析构函数 ******************/
	~Stock();		// 析构函数的参数必须是void
/*************************************************/

	void buy	(long, double);
	void sell	(long, double);
	void update	(double);

/******************* const成员函数 **************************/
	void show	(void) const;  // 保证调用它的对象不会被这个函数更改; 如果没有加上const, 则const对象调用他的时候将会报错;
/************************************************************/

	const std::string GetCompany(void) const {return company;}  // 由于访问的限制, 所以程序不能直接访问company显示公司名称
																// 这里提供一个GetCompany方法, 将操作限制为只能读取, 不能改写;

/************************ this指针 ****************************/
	// 每个成员函数(包括构造函数和析构函数)都有一个this指针, this指针指向调用对象, company = "xx";实际上是this->company = "xx";的缩写

		// 比较两个对象中股值较大的对象, 返回较大的那个
	const Stock GetBigger(const Stock & s) const;	// 一个隐式的参数对象return *this;实现返回, 一个显示的参数Stock对象
  //const Stock GetBigger(const Stock * this, const Stock & s);  以前C++的代码可能将其转化成了类似的这样的c代码
  //sTemp.GetBigger(s); => GetBigger(&sTemp, s);
		// 传进来的对象如果和调用对象是同类型可以直接使用私有数据s.tot_val; 如果不是就不能直接使用, 如下:
	//const void Try(const TempClass & t) const{t.db;}	// ERROR: TempClass::db 已声明不可访问
/************************************************************/	

/*********************** 作用域为类的常量 ********************/
		// 对于常量, 由于该常量对于所有对象来说都是相同的, 所以创建一个所有对象共享的常量是一个不错的注意, 但是这是行不通的, 
		// 声明类只是描述了对象的形式, 没有创建对象, 所以没有分配存储空间;
private:
	//const int Months = 12; // ERROR: 这里给数据分配了内存空间, 与声明类不分配内存空间相悖;

		// 第一个解决方案
			// 声明枚举类型
	enum{Mouths = 12};	// 这种方式声明枚举并不会创建数据成员, 也就是说, 所有对象都不包含枚举;
						// Mouths只是一个符号名称, 在作用域为整个类的代码中遇到他时, 编译器将用30替换它;

		// 第二种解决方案
			// 使用关键字static
	static const int Days = 30;	// 该常量将与其他静态变量存储在一起, 而不是存储在对象中;
								// 因此, 只有一个Mouths常量, 被所有Bakery对象共享;

	double M[Mouths][Days];

/*************************************************************/
};

#endif