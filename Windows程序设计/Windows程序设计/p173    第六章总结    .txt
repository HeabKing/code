第六章 键盘

8种键盘事件:
	1. 4种击键消息:
		WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, WM_SYSKEYUP;
	2. 4种字符消息:
		WM_CHAR, WM_DEADCHAR, WM_SYSCHAR, WM_SYSDEADCHAR;
		

// 6.1 键盘基础

1. windows使用八种不同的消息表示各种键盘事件;

	// 6.1.1 忽略键盘

2. 击键种类:
	2.1 系统功能击键
		2.1.1 一般包含Alt键;
		2.1.2 程序不必监控这些击键, windows会将击键效果通报给程序;
	2.2 与程序菜单相关的击键
		传递给相应窗口的窗口过程, 最终, 窗口过程得到一个表明某菜单项已经被选中的消息, 通常这就是窗口过程所需要知道的全部;

	// 6.1.2 谁获得了焦点?

3. 具有输入焦点的窗口要么是活动窗口, 要么是活动窗口的子窗口, 或者是活动窗口的子窗口的子窗口;
4. 活动窗口的鉴别:
	4.1 总是最上层的窗口, 他的父窗口句柄是NULL;
	4.2 如果一个活动窗口有标题栏, windows会加亮显示其边框;
	4.3 如果活动窗口目前处于最小化状态, windows将突出显示它在任务栏中的条目, 就像一个按下的按钮似的;
5. 有时候没有窗口具有输入焦点(如: 所有程序都最小化时), 但是windows仍将发送键盘消息给活动窗口, 只不过此时的消息形式 不同于 活动窗口没有最小化时发送的键盘消息;

	// 6.1.3 队列和同步

6. 正确处理击键的过程是:
	windows和键盘设备驱动程序将硬件扫描码转换为格式化后的消息 -> windows把这些消息存储在系统消息队列中 -> windows应用程序完成对前一个用户输入消息的处理后, Windows从系统消息队列中取出下一条消息, 并将它放入应用程序消息队列;
	这是一种两步处理法, 原因是要同步, 被期望接受键盘输入的窗口是有活动焦点的窗口, 用户输入的速度可能快于应用程序能处理的击键动作, 而一个特殊的击键可能会使焦点从一个窗口转换到另一个窗口, 后续的击键也会跟着到了另一个窗口;但是如果后续的击键已经被转到了目的窗口, 且被放置在了应用程序消息队列中, 则他们不能被输入到另一个窗口;

	// 6.1.4 击键和字符

7. 按下是一次击键, 释放也是一次击键, 对于产生可显示字符的击键组合, windows在发送击键消息的同时还发送字符消息;

// 6.2 击键消息

8. GetMessageTime函数可以得到键被按下或释放的时间;

	// 6.2.1 系统击键和非系统击键

9. 如果你在窗口过程中编码去捕捉SYS系统击键消息, 则在处理完成后, 仍然需要发送这些消息给DefWindowsProc以便不影响windows对他的处理;
10. 几乎所有影响程序窗口的消息都将先经过窗口过程, 仅当应用程序传递消息给DefWindowProc函数时, windows才会处理这些消息;
11. 不与Alt组合时按下和释放会产生WM_KEYDOWN和WM_KWYUP消息, 应用程序可以使用或者丢弃这些击键消息, !windows也不会处理他们!;
12. 对于所有四类击键消息, wParam是虚拟键代码, 用于标识哪个键被按下或被释放, 而lParam包含属于本次击键的一些其他数据;

		// 6.2.2 虚拟键代码

13. 大多数虚拟键代码命名是以VK_开头的;

	// 6.2.3 lParam信息

14. 32位的lParam消息被分成了6个字段;
	1. 16位重复计数;
		表示击键的数目, 如果按下一个键不放, 且窗口过程不足够快, 跟不上输入速率, windows就会把 !一些! WM_KEYDOWN和WM_SYSKEYDOWN消息合并成一个单独的消息, 并相应增加重复计数字段;
	2. 8 位OEM扫描码;  (Original Equipment Manufacturer, OEM原始设备制造商, 在这里指"IBM标准");
		键盘硬件产生的代码;
	3. 拓展键标记;
		如果击键结果来自IBM加强型键盘的附加键, 则拓展键标记为1, windows程序通常忽略拓展键标记;
	4. 内容代码;
		如果在击键的同时也按下了Alt键, 则内容代码为1;
		WM_SYSKEYUP和WM_SYSKEYDOWN消息此位始终为1, 而WM_KEYUP和WM_KEYDOWN消息此位时钟为0, 有两种情况例外:
			1. 活动窗口最小化了, 则他不具有输入焦点, 所有击键将产生WM_SYSKEYUP和WM_SYSKEYDOWN消息, 如果Alt键未被按下, 内容代码字段将被置0; windows处理WM_SYSKEYUP和WM__SYSKEYDOWN消息, 使最小化的活动窗口不处理这些击键;
			2. 在某些非英语的键盘上, 一些字符是通过Shift键, Ctrl键或Alt键同另一个键的组合产生的, 在这种情况下, 内容代码被设置为1, 但消息并不是系统击键消息;
	5. 键的先前状态;
		如果键以前是处于释放状态, 则键的先前状态为0, 而如果键以前是按下的, 则键的先前状态为1, 该位为1表名, 消息为重复击键产生的第二个或后续发出的消息;
	6. 转换状态;
		如果键正在被按下, 转换状态为0, 如果键正在被释放, 转换状态为1, DOWN: 0, UP: 1;

	// 6.2.4 转义状态

15. 转义键: Shift; Ctrl; Alt;
	切换键: Caps Lock; Num Lock; Scroll Lock;
	是否有转义键或切换键被按下:
		iState = GetKeyState(VK_SHIFT);

	// 6.2.5 使用击键消息

16. windows程序通常为不产生字符的击键(如: 转义键和切换键产生的转义状态信息)使用WM_KEYDOWN消息, 尽管你认为有可能可以通过使用击键消息和转义状态信息, 把击键消息转换为字符, 但也不要这样做. 你讲会在非英语键盘上遇到问题, 例如, 如果你获得wParam参数等于0x33的WM_KEYDOWN消息, 你知道用户按下了数字键3, 到目前为止, 一切都还不错, 如果你使用GetKeyState函数, 且发现Shift键被按下, 你也许会认为用户在输入"#", ,未必如此, 例如英国用户就是在输入"";

	// 6.2.6 为SYSMETS加上键盘处理功能

17. SendMessage(hwnd, message, wParam, lParam); 给窗口过程发送消息, 窗口过程处理完windows才把控制权交给紧跟着SendMessage调用的下一条语句;
	hwnd可以是同一个窗口过程, 也可以是统一程序的其他窗口过程, 甚至是另一个应用程序的窗口过程;

// 6.3 字符消息

18. TranslateMessage(&msg);  通过转义状态信息可把击键消息转换为字符消息, 仅仅利用转义状态信息是不够的, 还必须知道与国家/地区相关的键盘配置.
	本函数负责把击键消息转换为字符消息, 如果击键消息时WM_KEYDOWN或WM_SYSKEYDOWN, 且击键和转义状态组合产生了一个字符, 则TranslateMessage函数把字符消息放入应用程序的消息队列, 这个字符消息将被放在击键消息之后, GetMessage函数可以从消息队列中获取此字符消息;

	// 6.3.1 四类字符消息

19. 字符消息可分为四类:
	WM_CHAR, WM_DEADCHAR, WM_SYSCHAR, WM_SYSDEADCHAR;
	字符消息中的lParam与击键消息中的一致, wParam不再是虚拟键代码, 它是ANSI或Unicode字符码;


	// 6.3.2 消息排序
	// 6.3.3 控制字符的处理

20. 处理击键和字符消息的基本规则:
	1. 如果需要读取输入到窗口中的键盘字符, 处理WM_CHAR消息;
	2. 如果需要读取光标键, 功能键, delete键, insert键, Shift键, ctrl键, 则处理WM_KEYDOWN消息;

	// 6.3.4 死字符消息

21. 在一些非美国英语键盘上, 某些键可以给字母加上音调, 这些键称为"死键", 因为他们自己不产生字符;

// 6.4 键盘消息和字符集
	// 6.4.1 KEYVIEW1程序 -- 八种键盘事件
	// 6.4.2 非英语键盘微问题
	// 6.4.3 字符集和字体

22. GetKeyNameText(LONG lParam, LPWSTR szKeyName, sizeof(szKeyName) / sizeof(TCHAR));  从字符消息中获取键名称的字符串;
23. GetTextFace(hdc, LF_FACESIZE, szFaceName);  获取字体字样名称
24. windows有三种字体:  ps: 在默认的设备环境中得到的位图字体称为系统字体;
	1. 位图字体(bitmap fonts): 每一个字符由对应于显示器的像素的一组位值定义, 可以放大到较大的尺寸, 但字体看起来有锯齿, windows在标题栏, 菜单, 对话框, 按钮中使用位图字体;
	2. 矢量字体(vector fonts): 由简单的线条组成, 没有填充区域, 可以缩放至任意大小, 字符看起来有些单薄;
	3. True Type:			   由填充区域来定义字符的轮廓字体, 字体定义中包含的"提示"信息能够避免造成难看的或不可读的文本舍入问题, 显示器和打印机的输出时准确匹配的;
25.	GetStockObject中使用的字体标识符: 
	SYSTEM_FONT:		字样名称为System	ANSI字符集 默认的设备环境中得到的位图字体称为系统字体;
	SYSTEM_FIXED_FONT:	字样名称为FixedSys	系统字体的等宽字体版本;
	OEM_FIXED_FONT:		字样名称为Terminal  这里的OEM指IBM	
	DEFAULT_GUI_FONT:	字样名称为宋体		非系统字体, 一种位图字体;
	ANSI_FIXED_FONT:	字样名称为Courier					
	ANSI_VAR_FONT:		字样名称为MS Sans Serif
	DEVICE_DEFAULT_FONT:字样名称为System	ANSI字符集
26. 对于许多标准控件和用户界面组来讲, windows不采用系统字体, 而采用字体名为MS Sans Serif的字体, 这是一种位图字体, 可以在GetStockObject中采用DEFAULT_GUI_FONT标识符获得此字体;

	// 6.4.4 Unicode解决方案
	// 6.4.5 TrueType字体和大字体

// 6.5 插入符号(不是光标)

27. 五个基本的插入符号函数:
	1. CreateCaret: 创建和窗口关联的插入符号;
	2. SetCaretPos: 设置窗口内的插入符号的位置;
	3. ShowCaret: 显示插入符号;
	4. HideCaret: 隐藏插入符号;
	5. DestroyCaret: 销毁插入符号;
	另外还有: GetCaretPos: 获取当前插入符号位置; GetCaretBlinkTime: 获得插入符号闪烁时间; SetCaretBlinkTime: 设置插入符号闪烁时间;
28. 使用插入符号的主要规则: 在窗口过程处理WM_SETFOCUS消息时调用CreateCaret函数, 处理WMKILLFOCUS消息时调用DestroyCaret函数;
	其他规则: 创建的插入符号是隐藏的, 必须调用ShowCaret使之可见; 如果窗口过程处理的是一个非WM_PAINT消息, 但要在窗口内绘制某些东西, 他必须调用HideCaret隐藏插入符号, 当他结束在窗口内的绘制之后, 再调用ShowCaret来显示插入符号; HideCaret的效果是叠加的, 必须调用同样次数的ShowCaret;

	// 6.5.2 TYPER程序