关键字(.指定数据类型 .控制语句的执行顺序) 数据类型 标示符(我自己定的名字) 占位符.格式说明符
目标代码 启动代码 c库代码 ==>> 可执行文件.
赋值语句的执行顺序是从右到左
\n回车 \t tab键 \b 退格键只是退格, 没有删除字符的能力
函数重载: void aaa (int); void aaa (chars);
scanf ("%d.%d %d", &i, &j, &k); scanf ("%c.%c %c", &i, &j, &k);
语法错误: 把正确的c符号放在了错误的位置   语义错误: 用正确的语法表述了错误的意思, 编译器无法检查语义错误, 但是可以通过跟踪
	程序状态得到解决, 程序状态: 某个时刻所有变量的值
数据类型: k&r关键字: int long short unsigned char float double   
	  c90关键字: signed void   
	  c99关键字: _Bool _Complex(复数) _Imaginary(虚数)
16进制每位数恰好可以用4位二进制数表示, 例如, 十六进制的数字3是0011, 十六进制的5是0101 所以十六进制35的按位表示为0011 0101
long long int 8字节(64位) long int 4字节(32位) int 4字节(32位)或2字节(16位) short int 2字节(16位)
char类型: char是字节(8位) 编译器在进行处理的时候会把非数组内单独声明的一个char大胆的设置为4个字节(处理的更快)保存. 
	所谓的更多的位保存Unicode可以认为是:比如两个字节(两个char)保存一个汉字     书上说: c将字符常量视为int类型而不是
	char类型, 所以可以这样 char ch = 'FATE'; 但是不能这样: char c = 'FATEA';
直接操作硬件: 如直接访问cpu寄存器和内存单元
float 4字节 至少表示6个有效数字 double 8字节 至少表示10个有效数字
默认情况下编译器把浮点常量当做double类型, 列如: 假设flaot some; some = 2.0 * 4.0; 那么4.0和2.0被存储为double类型, (通常)
	使用64位进行储存, 乘积运算使用双精度, 结果被截为正常的float长度, 这能保证计算的精度, 但是会减慢程序的执行.
0xa.1fp10 = (10 + 1 / 16 + 15 / 256) * 2^10 = 10364.0;
进行类型转换的时候小数点后面的东西被截掉   但是进行%f---->%.2f的时候会进行四舍五入
printf()返回打印字符的个数, 包括空格和不可见的非打印字符(回车等), 如果输出失败则会返回负值
scanf() 以空白符作为读取间隔, 但是又一个例外, %c的时候会读取空白符
关于函数的调用的参数传递机制:
	1. 调用函数把实际参数放到堆栈中
	2. 被调函数从堆栈中取出数值
	3. 放入根据形式参数的类型确定在堆栈中的字节数, 而取出根据实际参量的类型进行取出, 现在的编译器很智能, 由于声明和调用
	   都是一样的类型, 所以即使形式参数类型不对也会根据声明原型中的类型进行类型转换, 但是会有例外的情况, 比如, 
	   prinf("%d%f", a, b)声明原型的时候并没有给出他的参数的类型和个数, 有点类似于标准c之前的声明原型, 这导致的结果是
	   编译器无法检查实际参数的个数和类型是否正确, 但是这正是printf()所需要的, 然后
	   它是通过有两个类型转换符知道后面还有两个参数, 然后根据形式参数a的类型,调用在堆栈
	   开辟对应个字节储存第一个参数, 第二个参数同理. 然后在被调函数pringf()对堆栈进行取值的时候则是根据 %d取4个字节, 
	   %f取8个字节(自动进行的类型转换double) -> 自动类型转换为double但是在使用double a;scanf("%f", &a);的时候为什么
	   会出现错误呢? 根据实际操作, 如果这样写的话, scanf不会更改a的值, 如果初始化的是a= 0; 则更改后输出a还是0