
创建对象的时候一定调用构造函数(默认构造函数, 复制构造函数可以系统自动生成, 还有自己定义的构造函数)
释放对象的时候一定调用析构函数
构造函数不会被继承, 析构函数不会被继承, 赋值运算符不会被继承;

一. 编译器自动生成的成员函数(特殊类方法)
	1. 默认构造函数
		(1) 自动生成的默认构造函数让你能够创建对象, 另一个重要功能是, 调用基类的默认构造函数函数和调用对象成员所属类的默认构造函数.
		(2) 如果派生类构造函数的成员初始化列表中没有显式的调用基类构造函数, 那么编译器将会使用默认构造函数来构造派生类对象的基类部分. 在这种情况下, 如果基类没有构造函数, 将会导致编译阶段的错误.
		(3) 如果定义了某种构造函数, 编译器将不会定义默认构造函数, 在这种情况下, 如果需要默认构造函数, 则必须自己提供.
	2. 复制构造函数
		(1) 在下列情况下会使用复制构造函数
			. 将新对象初始化为一个同类对象;  (ps: 初始化和赋值的区别 -- 初始化是给新对象进行初始化, 而赋值是修改已有对象的值. Star s; Star ss = s; s的创建调用了Star类的默认构造函数, 但是ss的创建由于创建和初始化在一起, 所以ss不会调用默认构造函数, 而是直接调用复制构造函数)
			. 按值将对象传递给函数;
			. 函数按值返回对象;
			. 编译器生成临时对象;  (baseDMA aa("hehe"); baseDMA a = baseDMA(aa); 这里初始化了一个临时对象用来初始化a对象, 用到了第一点和第三点)
		(2) 如果程序没有使用(显示或隐式)复制构造函数, 编译器将会提供原型, 但是不提供函数定义; 否则, 程序将定义一个执行成员初始化的复制构造函数. 也就是说, 新对象的每个值都被初始化为原始对象相应成员的值. 如果成员为类对象, 则初始化该成员的时候, 将会使用相应类的复制构造函数.
		(3) 在某些情况下, 成员初始化是不合适的. 列如: 使用new初始化的成员指针通常要求深复制, 或者类可能包含需要修改的静态变量. 在上述情况下, 需要定义自己的复制构造函数.
	3. 赋值运算符
		(1) 默认的赋值运算符用于处理同类对象之间的赋值. (比如hasDMA对象, 在初始化的时候不需要释放style指向的堆, 因为他还没指向任何值(初始化的新对象创建的时候不调用构造函数). 但是赋值的时候需要先释放style指向的堆)
		(2) 默认的位成员赋值, 如果成员为类对象, 则默认调用相应类的赋值运算符.
		(3) Animal & Animal::operator=(Aimal &); 允许animal = bird;的实现, is-a关系允许基类引用指向派生类对象, 赋值运算符只处理基类成员, 所以上述赋值操作将忽略bird对象的派生类成员
二. 其他的类方法
	1. 构造函数
		构造函数不同于其他的函数, 因为他创建新的对象, 而其他类方法只是被现有的对象调用. 这是构造函数不被继承的原因之一. 继承意味着派生类对象可以调用基类的方法, 然后, 构造函数在完成其工作之前, 对象并不存在
	2. 析构函数
		对于基类, 即使不需要析构函数, 也要定义一个虚析构函数使得释放派生类对象的时候能够正确调用派生类对象的析构函数, 然后用派生类的析构函数调用基类的析构函数.
	3. 转换
		(1) 使用一个参数就可以调用的构造函数定义了从参数类型到类类型的转换.
		(2) 将可转换的类型传递给 !以类为参数的函数! 时, 将会调用转换构造函数. 例如, Star north; north = "polaris"; 第二条语句将调用Star::operator=(const Star &)函数, 这个函数以类为参数, 所以会将"polaris"转化成Star对象, 这是通过调用Star::Star(const char *)实现的. 当然, 这个前提是没有定义Star Star::operator=(const Star &, char *); 函数.
		(3) 在带一个参数的构造函数原型中用explicit将禁止进行隐式转换, 但是仍然允许显式转换; 例如: explicit Star::Star(const char *); Star north; Star north = "polaris"(不允许); north = Star("polaris")(允许);
	4. 对象的按值传递与按引用传递
		通常应该按引用传递, 原因如下:
			(1). 效率高, 在没有修改对象的时候应该加上const. (按值传递要分配更大空间, 调用复制构造函数, 调用析构函数)
			(2). 在继承使用虚方法的时候, 被定义为接受基类引用参数的函数可以接受派生类.
	5. 返回对象和返回引用
		(1) 除非必须返回对象, 否则返回引用.原因:
			. 返回对象生成临时副本, 时间成本包括调用复制构造函数, 调用析构函数, 而返回引用则会节省时间和内存.
			. 返回引用和按引用传递对象相似, 调用和被调用的函数对同一个对象进行操作. !注意, 不能返回函数中创建的临时对象的引用.
	6. 使用const
		(1) 确保参数不被修改
		(2) 可以确保方法不修改调用它的对象 void Star::show()const   (const表示const Star * this);

有关使用基类方法的说明:
	1. 派生类对象自动使用继承而来的基类方法, 如果派生类没有从新定义该方法的话;
	2. 派生类的构造函数自动调用基类的构造函数.  ??不是只能自动调用默认的啊
	3. 派生类的构造函数自动调用基类的默认构造函数, 如果没在成员初始化列表中指定其他构造函数的话.
	4. 派生类构造函数显式的调用成员初始化列表中的指定基类构造函数.
	5. 派生类方法可以使用作用域解析运算符来调用公有的和受保护的基类方法.
	6. 派生类的友元函数可以通过强制类型转换, 将派生类的引用或指针转换成基类引用或指针, 然后使用该引用或指针来调用基类的友元函数.