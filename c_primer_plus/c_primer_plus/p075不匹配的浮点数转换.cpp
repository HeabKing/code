// 程序清单 4.12
// 不匹配的浮点数类型转换
#include <stdio.h>
int main(void)
{
	float n1 = 3.0;
	double n2 = 3.0;
	long n3 = 2000000000;
	long n4 = 1234567890;

	printf ("%.1e, %.1e, %.1e, %.1e\n", n1, n2, n3, n4);
	// 1. %e 对float和double都能用 %e 期望的是一个8字节的double类型 float在进行计算和做参数的时候会隐形的转化为double
	// 2. n3在这里是一个long int 类型的四字节整数, %e也会查看相邻的4个字节(改变n4会影响)
	// 3. 读取第三个%.1e的时候把n3和n4读到了一起
	printf ("%ld, %ld\n", n3, n4);
	printf ("%ld, %ld, %ld, %ld\n", n1, n2, n3, n4);
	// 1. 虽然n3和n4是对应的正确的类型符, 但是前面错误导致了后面的错误, 具体原因如下:
		// 参数传递的机制随实现的不同而不同, 下面的是我的计算机的实现方法:
		// printf ("%ld, %ld, %ld, %ld", n1, n2, n3, n4); 该调用告诉计算机把n1, n2, n3, n4的值传递给计算机,
		// 计算机把它们放到被称为堆栈的一块内存区域中来实现的. 计算机根据变量的类型而不是转换说明符把这些值放到堆栈中.
		// 所以n1在堆栈中占用8个字节(float转化成了double). 同样, n2占用8个字节, 而n3和n4则分别占用4个字节. 然后控制转移到
		// printf()函数. 该函数从堆栈吧值读取出来, 但是在读取时, 他根据转换说明符去读取, %ld说明符指出, 
		// printf()应该读取4个字节, 所以printf()在堆栈中读取前4个字节座位他的第一个值, 这就是n1的前半部分, 他被解释成一个
		// 长整数. 下一个%ld说明符再读取4个字节, 这就是n1的后半部分, 它被解释成第二个长整数, 同样, 
		// %ld的第三个和第四个实例似的n2的前半部分和后半部分被读出, 并被解释成两个长整数. 所以, 虽然n3和n4说明符都正确, 
		// 但是printf()仍然读取了错误的字节.
	// 2. 这种属于堆栈大于实际的错误, 还有一种是堆栈不够说明符使用的, 这个叫做堆栈溢出?? 以下面做个测试:
	printf ("%ld, %ld", n4);
	// 第二个%ld显示的是0, 不够了自己归零???反正明显不是堆栈溢出
	return 0;
}