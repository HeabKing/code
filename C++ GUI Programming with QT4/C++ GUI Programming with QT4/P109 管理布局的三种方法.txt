1.	绝对位置法, 人工布局法, 布局管理器法 --- 三种基本方法用于管理窗体上子窗口部件的布局

2.	绝对位置法 --- 最原始的摆放窗口部件的方法
	1.	对窗体的各个子窗口部件分配固定的大小和位置;	setGeometry(x, y, width, height);	
	2.	对窗体分配固定的大小和位置;					setFixedSize(width, height);
	3.	缺点:	(1) 用户无法改变窗口的大小  (2) 字体的改变可能引发文本截断  (3) 平台的风格差异导致的大小并不是总合适  (4) 人工计算位置和大小的枯燥乏味  (5) 维护工作困难

3.	人工布局法 --- 人工布局给定的大小尺寸总是可以和窗口的大小成比例
	1.	在绝对位置法中, 用户不能调整窗口的大小, 意味着不能产生paintEvent, 所以位置的设置只能在构造函数中写完
	2.	人工布局法给了程序一定的自由, 用户可以适当调整窗体大小, 所以有paintEvent产生
	3.	构造函数指定窗体的最小大小(setMinimumSize(width, height)), 然后指定窗体的初始大小(resize(365, 240))		resize 调整大小
	4.	在paintEvent()函数中指定各个窗口部件的大小, 最小大小与初始大小之间的空间差是用户可以调整的大小区间, 也是可以设置的窗口部件的调整区间(lineEdit->setGeometry(65, 9, 100 + width() - minimumWidth(), 25)) 
	5.	缺点:	(1) 依旧可能文本截断  (2) 平台问题依旧没有很好解决  (3) 人工依旧麻烦

4.	布局管理器 --- 最简便易行的解决方法
	======= 布局管理器的初始设置和使用拉伸因子占用多余空间 ================
	1.	布局管理器为每个类型的窗口部件提供一些合理的默认值
	2.	布局管理器并且会考虑每一个窗口部件的大小提示, 而窗口部件的大小提示通常又取决于窗口部件的字体, 风格, 内容
	3.	布局管理器也会考虑窗口部件的最小和最大尺寸
	4.	布局管理器能够响应字体的变化, 内容的改变, 窗口大小的调整
	5.	构造函数中创建布局管理器并把部件加进去, paintEvent就不用程序员考虑了
	6.	QLayout::setContentsMargins()	对话框周围的边白设置		QLayout::setSpacing()	两个子窗口部件之间的间隔设置
	7.	addStretch()调用告诉布局管理器, 它会占满布局中这一处的空间, Qt设计师中可以通过插入一个分隔符(spacer)来达到同样的效果
	8.	布局管理器会根据窗体中的子窗口部件的最小大小提示和大小提示, 从总体上为这个窗口设置一个最小尺寸 (合适大小呢???)
	======= 通过改变窗口部件的大小尺寸策略和大小提示来调整布局 ============
	1.	一个窗口部件的大小策略会告诉布局系统如何对他进行拉伸或者压缩
	2.	QSizePolicy:	
		--------- 水平垂直方向上的两个分量 --------------
		1.	Fixed	该窗口部件不能被拉伸或者压缩, 为固定大小
		2.	Minimum	该窗口部件的提示就是他的最小大小, 不能再压缩了, 但是 !如果有必要! 可以拉伸
		3.	Maximum	该窗口部件的大小提示就是他的最大大小, 不能再拉伸了, 但是可以压缩成他的最小尺寸
		4.	Preferred	该窗口部件的大小提示就是它比较合适的大小, 但是如果 !如果有必要! 还是可以对他进行拉伸或者压缩
		5.	Expanding	该窗口部件 !特别希望! 变长变高
		6.	Ignored		与Expanding相似, 只是他能够忽略窗口部件的大小提示和最小大小提示
		7.	MinimumExpanding	Qt老版本的极少数情况, 现在已经不会被用到
		--------- 水平垂直方向上的拉伸因子 --------------
		1.	拉伸因子可以用来说明在增大窗体时, 对于不同的子窗口部件应使用的放大比例
	3.	设置子窗口部件的最小大小, 最大大小或固定大小
	4.	派生重新实现sizeHint()函数, 由此获得所需的大小提示