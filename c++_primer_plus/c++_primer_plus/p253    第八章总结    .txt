第八章 函数探幽
. 内联函数
. 引用变量
. 如何按引用传递函数参数
. 默认参数
. 函数重载
. 函数模板
. 函数模板具体化

1.	可执行程序: 一组机器语言指令组成;
		运行程序时, 操作系统将这些指令载入到计算机内存中, 因此每条指令都有特定的内存地址, 计算机随后逐步执行这些指令;
2.	内联函数: 必须在声明 或 定义前加上关键字inline, 编译器不一定会满足这种要求(函数过大或函数调用了自己时);
3.	如果C语言的宏实现了类似函数的功能, 应该考虑将他们转换为C++的内联函数(因为内联函数是按值传递参数的);
4.	引用: 引用是C++新增的一种复合类型, 引用是已定义变量的别名, 必须在声明引用时将其初始化; 
		.函数是按值传递参数的:
			void fun(int a);  // 按值传递;
			int b = 1;
			fun(b);  // 等同于 int a = b; 把b的值初始化给了a;
			void fun(int & aa);
			int bb = 2;  // 按引用传递;
			fun(bb);  // 等同于 int & aa = bb; aa初始化成了bb的别名, 使得函数中的变量名称为调用程序中变量的别名;
5.	int & a = b; int * const a = &b;
6.	左值: 最初左值指的是可以出现在赋值语句左边的实体, 但是引入const之后, 常规变量和const变量都视为左值, 但是const变量属于不可修改的左值;
7.	生成临时变量的规则:
		1. 引用参数是const
		2. 实参的类型正确, 但是不是左值;
		3. 实参类型不正确, 但是可以转换成正确类型;
8. 不能将非const引用指向const常量; 不能将非const引用指向非左值; 只能将非const引用指向可修改的左值;
9. 常规函数的返回值是右值, 因为这种返回值位于临时内存单元中, 运行到下一条语句时, 他们可能已经不存在;
10. const string & str = "daxiong";
	1. string类中定义了const char * 到 string的转换;
	2. const引用中, 如果类型不匹配, 但是可以正确转换, 将会创建临时变量;
	3. 此时是对该临时变量的引用;
11. 左值: 变量, 数组元素, 结构成员, 引用和解除引用的指针; a; ar[1]; structa.str;  "heshixiong"(不可修改的左值);
	非左值: 字面常量(用引号括起来的字符串除外, 他们由其地址表示)和包含多项式的表达式; 1; a + 3;
	右值: 不能通过地址访问的值; 函数的返回值; 非左值包括右值;
12. 术语"多态": 指的是有多种形式; 术语"函数重载"指的是可以有多个同名的函数; 这两个术语是同一回事儿, 但是我们通常使用函数重载;
13. 在函数重载中没有匹配的类型c++会尝试使用标准类型转换强制进行匹配, 但是转换完成有多种选择c++将会拒绝这种调用并将其视为错误;
14. c++在检查函数特征标(参数列表)时将类型引用和类型本身视为同一个特征标;(double x 和 double & x视为同一类);
15. 返回类型可以不同, 但是特征标也 必须不同;
16. 模板并不创建任何函数, 而只是告诉编译器如何定义函数, 需要操作int类型时, 编译器将会按模板模式创建这样的函数, 用int代替T; 最终代码不包含任何模板;
17. 具体化:  注意: 试图在同一个文件(或转换单元)中使用同一种类型的显示实例和显示具体化将出错;
	1. 显示具体化: template<> Swap(int a, int b);
	2. 隐式实例化: int a, b; Swap(a, b); 编译器根据模板进行函数定义;
	3. 显示实例化:
		1. template void Swap<char>(char &, char &);  // 这时候编译器会直接根据模板生成函数定义;
		2. int a; double b; Swap<double>(a, b);  // 这里是显示实例化的另一种方法, 其实显示实例化就是用来解决这种问题的;  // 这里强制将参数转化成了double类型, 但是注意double & 的参数引用不能转换int变量a;
18. 具体化优于常规模板, 非模板函数优先于具体化和模板函数;
19. const和非const引用的区别只适用于指针和引用指向的数据; void f(int); void f(const int); 将会出现二义性;
20. int x; decltype(x) y; y的类型是int; decltype((x)) y; y的类型是int &;
21. 后置返回类型 template<class T1, class T2> auto fun(T1 x, T2 y) ->  decltype(x + y);