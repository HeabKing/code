// 关于(左值)引用的知识总结
// 1. 引用的经典用途是作为函数参数, 具体的说是结构和对象参数
// 2. 引用看起来像是(*指针), 但是还是有区别的, 必须在声明引用的时候将其初始化, 并且初始化以后就不能改变他的值了, 注意初始化的时候右值应该是一个变量名, g+1, 7 等都不是变量名称
// 3. 引用被用作函数参数, 使得函数中的变量名成为调用程序中的变量的别名, 这间接的成了 按引用传递使得被调用函数能够访问调用程序中的变量. c语言是按值传递, c语言通过指针避开这种限制, 但是按引用传递是对指针传递的完善和超越
// 4. !!20140814!!   引用甚至可以初始化为任何左值, 但是非左值只能用const引用来初始化, 因为非左值进行初始化的时候将会产生临时变量, 而我们使用引用作为函数参数的理由是想让他改变程序变量的值而不是临时变量的值, 所以这样可能发生不易发现的错误, 所以干脆禁止了产生临时变量, 除非你告诉c++我的是const引用, 本来就不打算修改值.
//	  const引用形参有一个属性: 假设实参的类型与引用参数类型不匹配, 但是可以被转换成引用类型, 程序将会创建一个正确类型的临时变量, 使用转换后的实参值来初始化它, 然后 传递一个指向该临时变量的引用.
//    左值: 变量, 数组元素, 结构成员, 引用和解除引用的指针, 非左值包括字面常量(用引号括起来的字符串除外, 它们由其地址表示)和包含多项的表达式
//    右值: 不能通过地址访问的值
// 5. 基类引用可以指向派生类, 无需进行强制类型转换   (继承: 将特性从一个类传递给另一个类的语言特性)

//======== 传递值 传指针 还是 传引用 ==========
// 对于使用传递值而不做修改的函数:
// 1. 如果对象很小, 如内置类型或小型结构, 则按值传递
// 2. 如果数据对象是数组, 则使用指针, 因为这是唯一的选择(???), 并将指针声明为指向const的指针
// 3. 如果数据对象是较大的结构, 则使用const指针或const引用, 以提高程序的效率
// 4. 如果数据对象时类对象, 则使用const引用, 类设计的语义常常要求使用引用, 这是c++新增这项特性的主要原因
// 对于修改调用函数中数据的函数:
// 1. 如果对象是内置数据类型, 则使用指针, !!因为这样的话看到fun(&x)则可以清楚地知道该函数修改x!!
// 2. 如果对象时数组, 则只能使用指针
// 3. 如果对象是结构, 则使用引用或指针
// 4. 如果对象时类对象, 则使用引用
// 总结: 内置类型和数组和结构使用指针, 类对象使用引用

#include <iostream>
using namespace std;
int main()
{
	int a = 1;
	int b = 2;
	int & aa = a;  // 声明aa为指向int变量的引用, 声明的时候必须初始化, 并且初始化了以后不能再改变
	aa = b;  // 并不是引用aa又开始表示b, 而是aa代表的a的值改变成了b的值
	
// 引用更像是const指针, 而且const指针也是声明的时候必须进行初始化
	int x = 9;
	int & xx = x;  // 这里的&不是运算符, 而是一个标示符, 告诉系统xx是一个 int变量的别名
	int * const xxx = &x;  // const指针声明的时候必须进行初始化, 然后引用其实就是对(*xxx)的伪装表示

// 如何使引用不能修改程序的值
	int f = 8;
	const int & ff = f;  // 这样作为函数参数传递的时候就能够既不用拷贝原来数据, 又能使用数据不修改他了
	//ff = 7;  // 不能修改了
	f = 7;

// 使用引用应该注意的一点
	int g = 7;
	// int & gg = g + 1; // 这样是不允许的, 因为g+1不是一个变量名称
	// int & gg = 7;  // 7 也不是一个变量名
	const int & gg = g + 1;

// 对指针类型的变量一样可以初始化
	int * h;
	int * & hh = h;

// 对函数能吗, 能!
	typedef void (*funtype)(int a);
	funtype fun;
	funtype & funfun = fun;

// 字符串呢? 可以使用const
	//char * & str = "heshixiong";  // 不可以, 因为字符串虽然不是非左值, 但是他的地址是(char [11])类型的
	//char * & str = (char *)"heshixiong";  // 不可以, 因为经过类型转换的右半部分已经不是左值了, 他会产生临时变量, 产生的临时变量只能用const类型的引用初始化
	char * const & str = "heshixiong";  // 这里进行了类型转换, 将(char[11])的指针变成了char *, 生成了char *的临时变量, 然后就初始化成功了
	char * const & strr = (char *)"heshixiong";

// 数组呢?
	int ar[5] = {1, 2, 3, 4, 5};
	int * const & arar = (int *)ar;
	cout << "关于数组: " << *arar <<" "<< arar[1] << endl; 

	///////////////////////////////////////
	string & str = "heshixiong";  // 不能生成临时变量
	const string & strstr = "heshixiong";  // 引用的临时变量
	// 1. string 类中有将char * 转换成string的方法;
	// 2. const应用在类型不匹配但是能进行转换的时候能生成临时变量;
	// 3. const引用实际上是引用的临时变量;
	////////////////////////////////////////

	return 0;
}